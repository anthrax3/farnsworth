#!/usr/bin/env python2
# -*- coding: utf-8 -*-

"""ExploitSubmissionCable model"""

from __future__ import absolute_import, unicode_literals

from datetime import datetime

from peewee import DateTimeField, ForeignKeyField, IntegerField, fn

from .base import BaseModel
from .challenge_set import ChallengeSet
from .exploit import Exploit
from .round import Round
from .team import Team


class ExploitSubmissionCable(BaseModel):
    """ExploitSubmissionCable model. Communicate what POV submit to ambassador"""

    round = ForeignKeyField(Round, related_name='exploit_submission_cables')
    team = ForeignKeyField(Team, related_name='exploit_submission_cables')
    throws = IntegerField()
    exploit = ForeignKeyField(Exploit, related_name='submission_cables')
    cs = ForeignKeyField(ChallengeSet, related_name='exploit_submission_cables')
    processed_at = DateTimeField(null=True)

    @classmethod
    def unprocessed(cls):
        """Return all unprocessed cables order by creation date descending."""
        print "UNPROCESSED IS DEPRECATED"
        return cls.select() \
                  .where(cls.processed_at.is_null(True)) \
                  .order_by(cls.created_at.desc())

    @classmethod
    def most_recent(cls):
        """Most recent exploit cable submissions for all unique CS and Team pairs"""
        join_query = cls.select(fn.MAX(cls.created_at).alias('created_at'), \
                                cls.cs_id, \
                                cls.team_id).group_by(cls.cs, cls.team).alias('jq')

        return cls.select().join(join_query, on=((cls.cs_id == join_query.c.cs_id) & \
                                          (cls.team_id == join_query.c.team_id) & \
                                          (cls.created_at == join_query.c.created_at)))

    @classmethod
    def cable_exists(cls, team, cs, round_=None):
        """True if cable exists for the team, cs, and round"""

        if round_ is None:
            round_ = Round.current_round()

        return cls.select().where(cls.team == team,
                                  cls.cs == cs,
                                  cls.round == round_).exists()

    @classmethod
    def most_recent_for_team(cls, team, cs):
        """Return most recent exploit submitted to team `team` for challenge_set `cs`"""
        first_s = cls.select() \
                     .where((cls.team == team) & (cls.cs == cs))\
                     .order_by(cls.created_at.desc()).first()

        return None if first_s is None else first_s.exploit

    def process(self):
        self.processed_at = datetime.now()
        self.save()
